# Безопасность

Данный туториал позволит реализовать регистрацию, аутентификацию и авторизацию на основе безопасного хранения
хэша от пароля с солью.

# Инструкции

## Модель
В пакете model создадим класс User, который будет сохраняться в базе данных. Данный класс в процессе будем 
наполнять различными методами. Что касается полей, которые отображаются в столбцы таблицы БД, то их три

```java
@Entity
public class User extends Model {

    /**
     * Email - электронная почта пользователя
     */
    @Id
    @Email
    private String email;

    /**
     * Хэш пароля
     */
    private String passwordHash;

    /**
     * Соль, случайная последовательность символов, используется для хэширования пароля ,
     * хранится для каждого пользователя своя.
     */
    private String salt;

    public User(String email, String password) {
        this.email = email;
        setPassword(password);
    }

    /**
     * Объект для связи с СУБД. Для поиска объектов в базе данных
     */
    public static Finder<String, User> find = new Finder<String, User>(User.class);

}
```

## Регистрация

### Сценарий
Мы будем регистрировать пользователя с помощью формы ввода email и пароля. 

Предварительно проверим:
1. Проходят ли валидацию поля email и password?
2. Зарегистрирован ли уже пользователь с таким email?

Если все хорошо, то создадим пользователя в базе:
1. Сгенерируем соль. 
2. Вычислим хэш от соли с паролем
3. Сохраним в базе email, соль и хэш. 


### Хэширование с солью
Создадим вспомогательные методы в модели, необходимые для генерации соли, вычисления хэша.
Для этого добавим в класс User следующие методы

```java
/**
 * Генерирует хэш от строки.
 * Определяет текущую версию выбранного алгоритма конкретной криптосистемы
 *
 * @param s строка
 * @return хэш от пароля в соответствии с применяемым алгоритмом
 */
private String getHash(String s) {
    return SHA256(s);
}

/**
 * Возвращает хэш-функцию SHA-256
 *
 * @see <a href="https://ru.wikipedia.org/wiki/SHA-2">SHA-2 в Википедии</a>
 *
 * @param str строка для хэширования
 * @return хэш от строки
 */
public static String SHA256(String str) {
    try {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        digest.update(str.getBytes());
        return Base64.encodeBase64String(digest.digest());
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(e);
    }
}

/**
 * Генерирует случайную строку для использования в качестве соли
 * @return случайная последовательность символов
 */
public static String genSalt(){
    final Random r = new SecureRandom();
    byte[] salt = new byte[32];
    r.nextBytes(salt);
    return Base64.encodeBase64String(salt);
}
```

Кроме того в PlayFramework есть класс Crypto в т.ч. для вычисления хэша с использованием секрета приложения, 
которым подписываются куки для хранения сессии. 
```java
/**
 * Подписывает строку СЕКРЕТОМ приложения с помощью встроенной в Play библиотекой Crypto
 * Используется алгоритм SHA-1
 *
 * @link play.api.libs.Crypto.sign
 * @see play.api.libs.Crypto.cookieSigner().sign(String)
 *
 * @param str Строка для подписи (хэширования)
 * @return подпись, хэш для заданной строки
 */
public static String SHA1(String str){
    //Используется класс Crypto из пакета, встроенного в Play
    return Crypto.cookieSigner().sign(str);
}
```
Вы вольны выбирать какую из двух предложенных хэш-функций использовать в getHash(). 

В итоге, с точки хрения модели данных после прохождения всех проверок нам необходимо будет по строке пароля 
сгенерировать два поля в БД: соль и хэш. Для этого можем добавить метод в класс User, setPassword(String). Он же 
будет использоваться в последствии, при смене пароля, если потребуется. 

> Обратите внимание, что мы его уже использовали в конструкторе класса User. 

```java
/**
 * Устанавливаем новый пароль для пользователя.
 *
 * @param password (новый) пароль
 */
public void setPassword(String password) {
    //Сгенерировать соль
    this.salt = genSalt();
    //установить хэш от пароля (с солью)
    this.passwordHash = getHash(password+salt);
}
```

### Форма регистрации
Напомним, что любая форма - это три составляющие: 
1. шаблон формы
2. модель формы для валидации
3. один контроллер, выдающий пустую форму, другой - ее обрабатывающий


Начинаем с модели, затем рассмотрим экшны контроллера Auth, и закончим шаблонами. 

#### Модель формы регистрации
В пакете models создадим класс Register. Эта модель НЕ будет сохраняться в базу данных. Она нужна лишь для определения
полей формы с целью навешивания валидации. Для простой обработки формы нативными средствами через фабрики форм и валидаторы.

```java
/**
 * Данный класс необходим для обработки формы регистрации.
 * Используется для валидации двух типов.
 *
 * 1. В качестве валидации отдельных полей используются аннотации
 * @Email - строка соответствует адресу эл. почты
 * @Required - обязательное поле.
 *
 * Для задания осмысленного сообщения при наарушении данного ограничения,
 * используется параметр message.
 * @Email(message = "Некорректный адрес электронной почты")
 *
 *
 * 2. Валидация на уровне формы с помощью метода String validate()
 * Когда нет возможности ограничиться валидацией полей по отдельности,
 * например когда условие валидации зависит от соответствия значений нескольких полей,
 *
 * Валидация форма регистрации проходит тогда, когда пользователь с данным email еще не зарегистрирован
 *
 */

public class Register{

    @Email(message= "Некорректный адрес электронной почты")
    @Required(message = "Обязательное поле")
    public String email;

    @Required(message = "Обязательное поле")
    public String password;

    /**
    * Дополнительный метод валидации формы.
    * Возвращает текст ошибки. В случае успеха валидации, возвращает null.
    */
    public String validate() {
        boolean available = User.emailAvailable(email);
        return available ? null : "Пользователь с данным почтовым адресом уже зарегистрирован";
    }
}
```
Аннотации @Required и @Email проверяют наличие и формат адреса почты соответственно. 
Обратите внимание, как задается человеческий текст ошибки для провала валидации с помощью message. 

Для того чтобы проверить, что пользователь с таким email зарегистрирован этого мало, нужна дополнительная валидация.
Поэтому мы создаем метод String validate(). Это типовой метод со стандартной сигнатурой. Именно так он должен нзываться, 
не принимать параметров и возвращать строку с ошибкой. 

Метод validate() мы сами ручками нигде не вызываем. Он будет пассивно вызван при валидации посредством механизма
Form.bindFromRequest() -> Form.hasErrors(). Нам необходимо лишь задать этот метод, который добавляет ДОПОЛНИТЕЛЬНУЮ 
валидацию для формы к тем валидациям, которые задаются с помощью @Required и @Email.

Мы использовали метод User.emailAvailable(email) для проверки, доступен ли данный почтовый адрес для регистрации.
Его у нас еще не было, поэтому добавим его в класс User:
```java
/**
 * Существует ли пользователь с данным почтовым адресом
 * @param email адрес электронной почты
 * @return false в случае, если пользователь с данным почтовым адресом уже зарегистрирован в системе.
 * Иначе возвращает true
 */
public static boolean emailAvailable(String email) {
    return (find.byId(email) == null);
}
```


#### Контроллеры формы регистрации
Для всех наших контроллеров связанных с безопасностью, создадим класс Auth в пакете controllers. Подключим фабрику форм,
поскольку большая часть работы будет вестись именно с ними.
```java
public class Auth extends Controller {

    private final FormFactory formFactory;

    @Inject
    public Auth(FormFactory formFactory) {
        this.formFactory = formFactory;
    }
    
    //добавлять методы-контроллеры будем сюда
    // МАРШРУТЫ В conf/routes  !!!
}
```

> Здесь и далее: НЕ ЗАБУДЬТЕ ДОБАВИТЬ МАРШРУТЫ В conf/routes в стиле REST для КАЖДОГО метода контроллера! 
Их приводить здесь не будем, оставим это для самостоятельного упражнения.

Добавим методы контроллеры для выдачи пустой формы регистрации и ее обработки:

```java
    /**
     * Страница выдает пустую форму регистрации.
     * Если осуществлен вход(логин) перенаправляет на гл. страницу
     * @return пустая форма регистрации.
     */
    public Result signup() {
        if (session("email") != null) return redirect(routes.HomeController.index());
        else return ok(register.render(formFactory.form(Register.class)));
    }

    /**
     * Обработка формы регистрации.
     * Производится валидация формы. Штатными средствами класса Register
     *
     * Проверяется, что данный email еще не зарегистрирован в системе.
     *
     *
     * @return В случае успеха создает пользоваетеля в базе, аутентифицирует и перенаправляет на гл. страницу.
     */
    public Result register() {
        Form<Register> regForm = Form.form(Register.class).bindFromRequest();
        if (regForm.hasErrors()) return badRequest(register.render(regForm));  // валидация формы не прошла
        else {
            //Из формы достаем объект класса Register, нашу модель формы регистрации с заполненными полями
            Register reg = regForm.get();
            // В конструкторе пользователя производится установка хэша от пароля с солью
            User user = new User(reg.email, reg.password);
            // Сохраняем в БД
            user.save();
            // аутентифицируем пользоваетеля, устанавливаем ему ключ в сессии
            session("email", reg.email);
            // перенаправляем куда нам нужно после успешной аутентификации
            return redirect(routes.HomeController.index());
        }
    }
```
Первый метод signup() выдает  пустую форму, определенную в шаблоне register.scala.html, который добавим позже. 
А метод register() выполняет весь сценарий регистрации.

 
#### Шаблоны формы регистрации
В заваершении этого сценария регистрации остается только добавить форму, используя наши хэлперы.

Создадим файл register.scala.html в  пакете views, где все шаблоны
```scala
@(regForm: Form[Register])
    @main("Регистрация") {
        @if(regForm.hasErrors) {
            <div class="alert alert-danger">
                <a class="close" data-dismiss="alert">x</a>
                @if(regForm.errors.size() > 0) {
                    @for((key, value) <- regForm.errors) {
                        @for(err <- value) {
                            <p>@err.message().toString()</p>
                        }
                    }
                }
            </div>
        }

        @helper.form(routes.Auth.register()) {
            @bootstrap.text(regForm("email"), "Email", 'type -> "email")
            @bootstrap.text(regForm("password"), "Пароль", 'type -> "password")
            <div class="form-group">
                <button type="submit" class="btn btn-primary">Зарегистрироваться</button>
            </div>
        }
    }
```

> Если забудете прописать маршруты, то шаблон не скомпилируется, т.к. использует реверсные пути routes.Auth.register()

Здесь используется немножко магии Scala для генерации блока [Alert](https://getbootstrap.com/docs/4.0/components/alerts/) 
в случае возникновении ошибок валидации формы. На самом деле на уровне интуиции это обычный if проверяет, наличие ошибок,
если есть, то добавляется блок alert и в цикле выводятся все тексты ошибок. Поробнее про выражения @if и @for в шаблонах
[Twirl](https://www.playframework.com/documentation/2.6.x/ScalaTemplates#Iterating).

## Логин, вход в систему

### Сценарий
Мы будем аутентифицировать пользователя в случае, если 
1. email и пароль не пусты и в нужном формате
2. В базе существует пользователь с такой комбинацией email + хэш от пароля с солью.
Для этого
1. Проверим валидацию полей формы по отдельности.
2. Поищем пользователя с таким email в базе. Если не найдем, выдадим ошибку.
3. Если пользователь есть, то из базы возьмем его соль и хэш от пароля.
4. По предъявленному паролю из форму и хэшу сгенерируем хэш от предъявленного пароля и сравним с хэшем в базе

### Вспомогательные методы в модели User
Определим вспомогательный метод checkPassword(password) в классе User, который будет проверять соответствует ли данному пользователю
предъявленный пароль
```java
 /**
     * Проверяем подошел ли пароль
     *
     * @param password пароль
     * @return в случае совпадения пароля, возвращет true, иначе возвращает false
     */
    private boolean checkPassword(String password) {
        return getHash(password+salt).equals(passwordHash);
    }
```
На базе этого метода уже можно сделать вспомогательный метод authenticate(email, password), который нужен для валидации
формы логина и может быть размещен как в соответствующей модели валидации формы логина, так и в классе User.

```java
    /**
     * @param email почтовый адрес
     * @param password пароль
     * @return возвращает null в случае успешной аутентификации.
     * В случае если пользователь не зарегистрирован возвращает сообщение об ошибке 
     * "Пользователь с данным email не зарегистрирован или не верный пароль"
     */
    public static String authenticate(String email, String password) {
        User user = find.byId(email);
        if (user == null || !user.checkPassword(password))
            return "Пользователь с данным email не зарегистрирован или не верный пароль";
        else
            return null;
    }
```

### Форма логина
#### Модель формы логина
В пакете models создадим класс Login для формы логина

```java

/**
 * Данный класс необходим для обработки формы логина.
 * Используется для валидации двух типов.
 *
 * 1. В качестве валидации отдельных полей используются аннотации
 * @Email - строка соответствует адресу эл. почты
 * @Required - обязательное поле.
 *
 * Для задания осмысленного сообщения при наарушении данного ограничения,
 * используется параметр message.
 * @Email(message = "Некорректный адрес электронной почты")
 *
 *
 * 2. Валидация на уровне формы с помощью метода String validate()
 * Когда нет возможности ограничиться валидацией полей по отдельности,
 * например когда условие валидации зависит от соответствия значений нескольких полей,
 *
 * Валидация форма логина проходит тогда, когда email и пароль соответствуют (хэши совпадают и т.д. и т.п.)
 *
 *
 */

public class Login {

    @Email(message = "Некорректный адрес электронной почты")
    @Required(message = "Обязательное поле")
    public String email;

    @Required(message = "Обязательное поле")
    public String password;

    // Валидация формы
    public String validate() {
        // Проверка соответствия логина и пароля
        return User.authenticate(email, password);
    }
}
```

#### Контроллеры формы логина
В класс Auth добавим методы для выдачи пустой формы. Дополнительно можем проверить, если пользователь уже залогинен, то
логинить его не будем, а перенаправим сразу на вход.

```java
/**
     * Страница выдачи формы для аутентификации
     * @return страница с пустой формой логин/пароль.
     *
     * NB: В случае, если пользователь уже аутентифицирован должна возвращать редирект на Application.index()
     *
     * Подсказка: воспользоваться генераторами форм на базе класса Login
     * Form.form(Login.class)
     *
     */
    public Result login() {
        if (session("email") != null) return redirect(routes.HomeController.index());
        else return ok(login.render(formFactory.form(Login.class)));
    }
```

Далее, после ввода данных, заполненная форма отправляется на обработку, а ее поля на валидацию средствами класса Login
```java
/**
     * Обработка формы аутентификации
     * Производит валидацию штатными средствами засчет Login.validate(). Он неявно вызывается при вызове
     *
     * loginForm.hasErrors()
     *
     * Подсказка: этот метод уже реализован для демонстрации.
     *
     * @return форму с ошибкой в случае не корректной валидации.
     * В случае успеха устанавливает ключ в сессии и перенаправляет на главную страницу
     */
    public Result auth() {
        Form<Login> loginForm = formFactory.form(Login.class).bindFromRequest();
        if (loginForm.hasErrors())
            //Ты не пройдешь!
            return badRequest(login.render(loginForm));
        else {
            //Пароль подошел. Устанавливаем ключ в сессии             
            session("email", loginForm.get().email);
            //ключик в краткосрочной памяти длявыдачи alert-ов
            flash("success","Вы успешно аутентифицировались. Добро пожаловать!");
            //перенаправляем на вход либо на главную страницу, либо в область администрирования
            return redirect(routes.HomeController.index());
        }
    }
```
> НЕ ЗАБУДЬТЕ ДОБАВИТЬ МАРШРУТЫ В conf/routes в стиле REST для КАЖДОГО метода контроллера! 


#### шаблон формы логина
В итоге нам необходимо определить шаблон login.scala.html в папке app\views, т.к. мы используем данное имя в 
методах-контроллерах обработки формы логина. 
```scala
@(loginForm: Form[Login])
    @main("Вход") {
        @if(loginForm.hasErrors) {
            <div class="alert alert-danger">
                <a class="close" data-dismiss="alert">x</a>
                @if(loginForm.errors.size() > 0) {
                    @for((key, value) <- loginForm.errors) {
                        @for(err <- value) {
                            <p>@err.message().toString()</p>
                        }
                    }
                }
            </div>
        }
        @helper.form(routes.Auth.auth()) {
            <h2 class="form-signin-heading">Вход</h2>
            
            @bootstrap.text(loginForm("email"), "Email", 'type -> "email")
            @bootstrap.text(loginForm("password"), "Пароль", 'type -> "password")

            <div class="form-group">
                <button type="submit" class="btn btn-primary">Войти</button> или
                <a href="@routes.Auth.signup()" class="btn btn-default">Зарегистрироваться</a>
            </div>
        }
    }
```

## Выход из системы
Для реализации выхода из системы реализуем контроллер в классе Auth, который будет очищать из сессии  установленный ключ email.
```java
    /**
     * Выход пользователя.
     * @return Осуществляет очистку сессии и перенаправление на главную страницу
     */
    public static Result logout() {
        session().clear("email");
        return redirect(routes.HomeController.index());
    }
```

В данном методе после выхода идет перенаправление на главную страницу, но есть еще вариант с перенаправлением на 
форму аутентификации. Это на ваше усмотрение.

> НЕ ЗАБУДЬТЕ ДОБАВИТЬ МАРШРУТЫ В conf/routes в стиле REST для КАЖДОГО метода контроллера! 


## Закрытая часть, только для аутентифицированных пользователей
Теперь мы можем войти и выйти и храним пользователей в базе. Осталось навесить защиту на определенные методы контроллера,
которые должны  быть доступны только аутентифицированным пользователям.

Если я хочу закрыть отдельный метод, например HomeController.list, то перед ним мы навешиваем аннотацию @Authenticated
```java
@Security.Authenticated
public Result list(){
    List<Feature> page = Feature.find.all();
    return ok(list.render(page));
}
```
Данная аннотация будет проверять, залогинены мы или нет, если не залогинены, то будет запрещать доступ. Чтобы привязать
к данной защите наш механизм аутентификации по паролю, надо его параметризовать классом реализующим интерфейс
Security.Authenticator 
```java
@Security.Authenticated(Secured.class)
public Result list(){
    List<Feature> page = Feature.find.all();
    return ok(list.render(page));
}
```

Это закроет только один метод вывода списка, а методы редактирования, удаления и т.п. закрыты не будут. Нужно будет 
перед каждым методом такую аннотацию прописать. Либо можно закрыть целый класс контроллера со всеми методами.
Например создать класс-контроллер Admin в пакете controllers и перенести в него все методы, которые должны быть
доступны только аутентифицированному пользователю, не забывая про изменение в таблице маршрутизации conf/routes. Затем 
навесить аннотацию на весь класс:

```java
@Authenticated(Secured.class)
class Admin extends Controller{
    //все методы защищены
}
```

> Обратите внимание, что методы логина, регистрации, смены пароля и др не должны быть закрыты аутентификацией, иначе
до них никогда нельзя будет добраться

Создадим этот класс Secured в любом пакете, унаследовав от Authenticator

Первый метод getUsername возвращает имя/логин/email пользователя, вошедшего в систему. 
Поскольку мы это реализуем через ключ в сессии,
то там же его и берем. Если же ключ в сессии не установлен, то метод getUserName вернет null. В данном случае система
защиты должна не пустить и куда-то перенаправить. По-умолчанию выдает просто 401 ошибку, Unauthorized. 
Можно перенаправлять на специальную страницу, или на форму логина. В некоторых сценариях форму логина прячут. 
Если не знаешь, на какой адрес заходить, не узнаешь. 

А вот куда именно перенаправить задать можно с помощью метода onUnauthorized. В нашем случае это перенаправление на форму
логина.
```java


public class Secured extends Security.Authenticator {
    /**
     * Механизм аутентификации
     *
     * @param ctx контекст запроса.
     * @return строку-email для текущего пользователя, хранящуюся в сессии при аутентификации. В случае ее отсутствия возвращает null
     */
    @Override
    public String getUsername(Context ctx) {
        return ctx.session().get("email");
    }

    /**
     * Перенаправление в случае неуспеха аутентификации. Как правило перенаправляет на форму логина
     *
     * @param ctx контекст
     * @return перенаправление на страницу логина
     */

	@Override
	public Result onUnauthorized(Context ctx) {
		return redirect(routes.Auth.login());
	}
}
```

# Задание для самостоятельной работы
Самостоятельно реализуйте функциональность смены пароля. Для этого залогиненный пользователь может перейти на данную
форму, где предлагается ввести старый пароль (текущий пароль) и два раза ввести новый пароль. Проверяется введенный 
старый пароль и совпадение значений двух полей нового пароля.

В случае успеха, сохраняется новый пароль (соль/хэш) в базе.