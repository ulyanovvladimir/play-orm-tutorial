# Безопасность

Данный туториал позволит реализовать регистрацию, аутентификацию и авторизацию на основе безопасного хранения
хэша от пароля с солью.

# Инструкции

## Модель
В пакете model создадим класс User, который будет сохраняться в базе данных. Данный класс в процессе будем 
наполнять различными методами. Что касается полей, которые отображаются в столбцы таблицы БД, то их три

```java
@Entity
public class User extends Model {

    /**
     * Email - электронная почта пользователя
     */
    @Id
    @Email
    private String email;

    /**
     * Хэш пароля
     */
    private String passwordHash;

    /**
     * Соль, случайная последовательность символов, используется для хэширования пароля ,
     * хранится для каждого пользователя своя.
     */
    private String salt;

    public User(String email, String password) {
        this.email = email;
        setPassword(password);
    }

    /**
     * Объект для связи с СУБД. Для поиска объектов в базе данных
     */
    public static Finder<String, User> find = new Finder<String, User>(User.class);

}
```

## Регистрация

### Сценарий
Мы будем регистрировать пользователя с помощью формы ввода email и пароля. 

Предварительно проверим:
1. Проходят ли валидацию поля email и password?
2. Зарегистрирован ли уже пользователь с таким email?

Если все хорошо, то создадим пользователя в базе:
1. Сгенерируем соль. 
2. Вычислим хэш от соли с паролем
3. Сохраним в базе email, соль и хэш. 


### Хэширование с солью
Создадим вспомогательные методы в модели, необходимые для генерации соли, вычисления хэша.
Для этого добавим в класс User следующие методы

```java
/**
 * Генерирует хэш от строки.
 * Определяет текущую версию выбранного алгоритма конкретной криптосистемы
 *
 * @param s строка
 * @return хэш от пароля в соответствии с применяемым алгоритмом
 */
private String getHash(String s) {
    return SHA256(s);
}

/**
 * Возвращает хэш-функцию SHA-256
 *
 * @see <a href="https://ru.wikipedia.org/wiki/SHA-2">SHA-2 в Википедии</a>
 *
 * @param str строка для хэширования
 * @return хэш от строки
 */
public static String SHA256(String str) {
    try {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        digest.update(str.getBytes());
        return Base64.encodeBase64String(digest.digest());
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(e);
    }
}

/**
 * Генерирует случайную строку для использования в качестве соли
 * @return случайная последовательность символов
 */
public static String genSalt(){
    final Random r = new SecureRandom();
    byte[] salt = new byte[32];
    r.nextBytes(salt);
    return Base64.encodeBase64String(salt);
}
```

Кроме того в PlayFramework есть класс Crypto в т.ч. для вычисления хэша с использованием секрета приложения, 
которым подписываются куки для хранения сессии. 
```java
/**
 * Подписывает строку СЕКРЕТОМ приложения с помощью встроенной в Play библиотекой Crypto
 * Используется алгоритм SHA-1
 *
 * @link play.api.libs.Crypto.sign
 * @see play.api.libs.Crypto.cookieSigner().sign(String)
 *
 * @param str Строка для подписи (хэширования)
 * @return подпись, хэш для заданной строки
 */
public static String SHA1(String str){
    //Используется класс Crypto из пакета, встроенного в Play
    return Crypto.cookieSigner().sign(str);
}
```
Вы вольны выбирать какую из двух предложенных хэш-функций использовать в getHash(). 
В итоге, с точки хрения модели данных после прохождения всех проверок нам необходимо будет по строке пароля 
сгенерировать два поля в БД: соль и хэш. Для этого можем добавить метод в класс User, setPassword(String). Он же 
будет использоваться в последствии, при смене пароля, если потребуется. 

> Обратите внимание, что мы его уже использовали в конструкторе класса User. 

```java
/**
 * Устанавливаем новый пароль для пользователя.
 *
 * @param password (новый) пароль
 */
public void setPassword(String password) {
    //todo Сгенерировать соль
    //todo установить хэш от пароля (с солью)
    this.salt = genSalt();
    this.passwordHash = getHash(password+salt);
}
```

### Форма регистрации
Напомним, что любая форма - это три составляющие: 
1. шаблон формы
2. модель формы для валидации
3. один контроллер, выдающий пустую форму, другой - ее обрабатывающий


Начинаем с модели, затем рассмотрим экшны контроллера Auth, и закончим шаблонами. 

#### Модель формы регистрации
В пакете models создадим класс Register. Эта модель НЕ будет сохраняться в базу данных. Она нужна лишь для определения
полей формы с целью навешивания валидации. Для простой обработки формы нативными средствами через фабрики форм и валидаторы.

```java
/**
 * Данный класс необходим для обработки формы регистрации.
 * Используется для валидации двух типов.
 *
 * 1. В качестве валидации отдельных полей используются аннотации
 * @Email - строка соответствует адресу эл. почты
 * @Required - обязательное поле.
 *
 * Для задания осмысленного сообщения при наарушении данного ограничения,
 * используется параметр message.
 * @Email(message = "Некорректный адрес электронной почты")
 *
 *
 * 2. Валидация на уровне формы с помощью метода String validate()
 * Когда нет возможности ограничиться валидацией полей по отдельности,
 * например когда условие валидации зависит от соответствия значений нескольких полей,
 *
 * Валидация форма регистрации проходит тогда, когда пользователь с данным email еще не зарегистрирован
 *
 */

public class Register{

    @Email(message= "Некорректный адрес электронной почты")
    @Required(message = "Обязательное поле")
    public String email;

    @Required(message = "Обязательное поле")
    public String password;

    /**
    * Дополнительный метод валидации формы.
    * Возвращает текст ошибки. В случае успеха валидации, возвращает null.
    */
    public String validate() {
        boolean available = User.emailAvailable(email);
        return available ? null : "Пользователь с данным почтовым адресом уже зарегистрирован";
    }
}
```
Аннотации @Required и @Email проверяют наличие и формат адреса почты соответственно. 
Обратите внимание, как задается человеческий текст ошибки для провала валидации с помощью message. 

Для того чтобы проверить, что пользователь с таким email зарегистрирован этого мало, нужна дополнительная валидация.
Поэтому мы создаем метод String validate(). Это типовой метод со стандартной сигнатурой. Именно так он должен нзываться, 
не принимать параметров и возвращать строку с ошибкой. 

Метод validate() мы сами ручками нигде не вызываем. Он будет пассивно вызван при валидации посредством механизма
Form.bindFromRequest() -> Form.hasErrors(). Нам необходимо лишь задать этот метод, который добавляет ДОПОЛНИТЕЛЬНУЮ 
валидацию для формы к тем валидациям, которые задаются с помощью @Required и @Email.

Мы использовали метод User.emailAvailable(email) для проверки, доступен ли данный почтовый адрес для регистрации.
Его у нас еще не было, поэтому добавим его в класс User:
```java
/**
 * Существует ли пользователь с данным почтовым адресом
 * @param email адрес электронной почты
 * @return false в случае, если пользователь с данным почтовым адресом уже зарегистрирован в системе.
 * Иначе возвращает true
 */
public static boolean emailAvailable(String email) {
    return (find.byId(email) == null);
}
```


#### Контроллеры формы регистрации
Для всех наших контроллеров связанных с безопасностью, создадим класс Auth в пакете controllers. Подключим фабрику форм,
поскольку большая часть работы будет вестись именно с ними.
```java
public class Auth extends Controller {

    private final FormFactory formFactory;

    @Inject
    public Auth(FormFactory formFactory) {
        this.formFactory = formFactory;
    }
    
    //добавлять методы-контроллеры будем сюда
    // МАРШРУТЫ В conf/routes  !!!
}
```

> Здесь и далее: НЕ ЗАБУДЬТЕ ДОБАВИТЬ МАРШРУТЫ В conf/routes в стиле REST для КАЖДОГО метода контроллера! 
Их приводить здесь не будем, оставим это для самостоятельного упражнения.

Добавим методы контроллеры для выдачи пустой формы регистрации и ее обработки:

```java
    /**
     * Страница выдает пустую форму регистрации.
     * Если осуществлен вход(логин) перенаправляет на гл. страницу
     * @return пустая форма регистрации.
     */
    public Result signup() {
        if (session("email") != null) return redirect(routes.HomeController.index());
        else return ok(register.render(formFactory.form(Register.class)));
    }

    /**
     * Обработка формы регистрации.
     * Производится валидация формы. Штатными средствами класса Register
     *
     * Проверяется, что данный email еще не зарегистрирован в системе.
     *
     *
     * @return В случае успеха создает пользоваетеля в базе, аутентифицирует и перенаправляет на гл. страницу.
     */
    public Result register() {
        Form<Register> regForm = Form.form(Register.class).bindFromRequest();
        if (regForm.hasErrors()) return badRequest(register.render(regForm));
        else {
            Register reg = regForm.get();
            User user = new User(reg.email, reg.password);
            user.save();
            session("email", reg.email);
            return redirect(routes.HomeController.index());
        }
    }
```
Первый метод выдает signup() пустую форму, определенную в шаблоне register.scala.html, который добавим позже. 
А метод register() выполняет весь сценарий регистрации.

 
#### Шаблоны формы регистрации
В заваершении этого сценария регистрации остается только добавить форму, используя наши хэлперы.

Создадим файл register.scala.html в  пакете views, где все шаблоны
```scala
@(regForm: Form[Register])
    @main("Регистрация") {
        @if(regForm.hasErrors) {
            <div class="alert alert-danger">
                <a class="close" data-dismiss="alert">x</a>
                @if(regForm.errors.size() > 0) {
                    @for((key, value) <- regForm.errors) {
                        @for(err <- value) {
                            <p>@err.message().toString()</p>
                        }
                    }
                }
            </div>
        }

        @helper.form(routes.Auth.register()) {
            @bootstrap.text(regForm("email"), "Email", 'type -> "email")
            @bootstrap.text(regForm("password"), "Пароль", 'type -> "password")
            <div class="form-group">
                <button type="submit" class="btn btn-primary">Зарегистрироваться</button>
            </div>
        }
    }
```

> Если забудете прописать маршруты, то шаблон не скомпилируется, т.к. использует реверсные пути routes.Auth.register()

Здесь используется немножко магии Scala для генерации блока [Alert](https://getbootstrap.com/docs/4.0/components/alerts/) 
в случае возникновении ошибок валидации формы. На самом деле на уровне интуиции это обычный if проверяет, наличие ошибок,
если есть, то добавляется блок alert и в цикле выводятся все тексты ошибок. Поробнее про выражения @if и @for в шаблонах
[Twirl](https://www.playframework.com/documentation/2.6.x/ScalaTemplates#Iterating).

# ... TO BE CONTINUED ...
 
 
